import * as client from '@botpress/client'

// TODO: these types should be generated by the CLI from interface and integration schemas

type BaseItem = { ID: string }

export type DataSourceEvents<T extends BaseItem> = {
  created: { item: T }
  updated: { item: T }
  deleted: { item: T }
}

export type EventInput<T extends BaseItem> = {
  [K in keyof DataSourceEvents<T>]: {
    event: DataSourceEvents<T>[K]
    state: SyncerState
  }
}

export type DataSource<T extends BaseItem> = {
  list: (input: { nextToken?: string }) => Promise<{ items: T[]; meta: { nextToken?: string } }>
  create?: (input: { item: T }) => Promise<{ item: T }> // only needed for the 2-way sync
  update?: (input: { item: T }) => Promise<{ item: T }> // only needed for the 2-way sync
  delete?: (input: { ID: string }) => Promise<{ ID: string }> // only needed for the 2-way sync
  on: <K extends keyof DataSourceEvents<T>>(event: K, handler: (args: EventInput<T>[K]) => Promise<void>) => void
}

export type SyncerOptions = {
  tableName: string
}

export type SyncerState = {
  nextToken?: string
  tableCreated: boolean
}

export class Syncer<T extends BaseItem> {
  public constructor(private dataSource: DataSource<T>, private client: client.Client, private options: SyncerOptions) {
    dataSource.on('created', this._onCreated)
    dataSource.on('updated', this._onUpdated)
    dataSource.on('deleted', this._onDeleted)
  }

  public async sync(state: SyncerState): Promise<SyncerState> {
    const { items, meta } = await this.dataSource.list(state)

    for (const item of items) {
      state = await this._upsert(state, item)
    }

    return { ...state, nextToken: meta.nextToken }
  }

  private _onCreated = async (args: EventInput<T>['created']) => {
    await this._upsert(args.state, args.event.item)
  }

  private _onUpdated = async (args: EventInput<T>['updated']) => {
    await this._upsert(args.state, args.event.item)
  }

  private _onDeleted = async (args: EventInput<T>['deleted']) => {
    await this._delete(args.state, args.event.item.ID)
  }

  private _upsert = async (state: SyncerState, item: T): Promise<SyncerState> => {
    if (!state?.tableCreated) {
      await this._createTableIfNotExists(item)
      return { ...state, tableCreated: true }
    }

    await this.client.upsertTableRows({
      table: this.options.tableName,
      rows: [item],
      keyColumn: 'ID',
    })

    return state
  }

  private _delete = async (state: SyncerState, ID: string): Promise<SyncerState> => {
    if (!state?.tableCreated) {
      return state ?? {}
    }

    await this.client.deleteTableRows({
      table: this.options.tableName,
      filter: { ID: { $eq: ID } },
    })

    return state
  }

  private _createTableIfNotExists = async (schema: object): Promise<void> => {
    const { tables } = await this.client.listTables({})
    const existingTable = tables.find((table) => table.name === this.options.tableName)
    if (!existingTable) {
      await this.client.createTable({
        name: this.options.tableName,
        schema, // should pass a json schema here, but the code generation of the CLI doesn't support it yet
      })
    }
  }
}
